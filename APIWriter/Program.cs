using System.Net.Http.Headers;
using System.Text;
using APIWriter;
using Pluralize.NET.Core;
using YamlDotNet.Core;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

var plural = new Pluralizer();
var web = new HttpClient();
var api = await web.GetStringAsync("https://raw.githubusercontent.com/trash-panda-mc/docs/master/static/openapi.yaml");
File.WriteAllText("openapi.yaml", api);

var deserializer = new DeserializerBuilder()
    .WithNamingConvention(UnderscoredNamingConvention.Instance)
    .Build();

dynamic doc;
using (var sr = new StringReader(api))
{
    doc = deserializer.Deserialize(new Parser(sr))!;
}

var components = doc["components"];
var parameterTypes = components["parameters"];
var schemas = components["schemas"];
var paths = doc["paths"];

var duplicates = new Dictionary<object, TypeDescription>();
var enumerations = new Dictionary<string, Enumeration>();
var descriptors = new Dictionary<string, Description>();
var methods = new Dictionary<string, Method>();
var names = new Stack<string>();

// Parse document
foreach (var param in parameterTypes)
{
    CreateTypeDescription(param.Key, param.Value["schema"]);
}

foreach (var schema in schemas)
{
    CreateTypeDescription(schema.Key, schema.Value);
}

foreach (var path in paths)
{
    foreach (var method in path.Value)
    {
        var name = method.Value["operationId"];
        names.Push(Camelize(name));

        var parameters = new Dictionary<string, TypeDescription>();
        if (method.Value.ContainsKey("parameters"))
        {
            foreach (var param in method.Value["parameters"])
            {
                var inType = param["in"];
                var paramName = param["name"];
                var schema = param["schema"];

                parameters[Camelize(paramName, false)] =
                    CreateTypeDescription(paramName, schema);
            }
        }

        methods[name] = new Method(GetName(), parameters);
        names.Pop();
    }
}


// Generate output file
var output = new StringBuilder();

output.AppendLine(@"
/*
 * This file is automatically generated.
 */

using System;
using boolean = System.Boolean;
using integer = System.Int32;

namespace Theseus.Avalonia;
".Trim());

foreach (var (name, enume) in enumerations)
{
    output.Append($"public enum {name}\n{{\n\t");
    output.AppendLine(string.Join(",\n\t", enume.Values));
    output.AppendLine("}");
}

foreach (var (name, desc) in descriptors)
{
    output.Append($"public struct {name}\n{{\n");
    output.Append(
        desc.Properties.Aggregate("",
            (cur, prop) =>
                cur +
                $"\t{prop.Value.Type}" +
                string.Concat(Enumerable.Repeat("[]", prop.Value.ArrayDepth)) +
                (prop.Value.Nullable ? "?" : "") +
                $" {prop.Key};\n"));
    output.AppendLine("}");
}

output.AppendLine(@"
public class ModrinthClient
{
    System.Net.Http.HttpClient client = new System.Net.Http.HttpClient();
    public ModrinthClient()
    {
        client.DefaultRequestHeaders.UserAgent.Add(
            new System.Net.Http.Headers.ProductInfoHeaderValue(""Theseus.Avalonia"", ""1.0""));
        client.DefaultRequestHeaders.UserAgent.Add(
            new System.Net.Http.Headers.ProductInfoHeaderValue(""(https://github.com/trash-panda-mc/theseus.avalonia)""));
    }
".Trim());
foreach (var (name, method) in methods)
{
    output.Append($"\tpublic dynamic {name}(");
    output.Append(
        string.Join(", ",
            method.Parameters.Select(
                p =>
                    $"{p.Value.Type}" +
                    $"{string.Concat(Enumerable.Repeat("[]", p.Value.ArrayDepth))}" +
                    $"{(p.Value.Nullable ? "?" : "")}" +
                    $" {p.Key}")));
    output.AppendLine(")\n\t{");
    
    // TODO
    output.AppendLine("\t\tthrow new NotImplementedException();");
    
    output.AppendLine("\t}");
}

output.Append("}");

File.WriteAllText("Modrinth.cs", output.ToString());


string Camelize(string name, bool capitalizeFirstWord = true)
{
    var result = "";

    var capitalize = capitalizeFirstWord;
    foreach (var character in name)
    {
        switch (character)
        {
            case '_':
                capitalize = true;
                continue;
            case '|':
                result += "Or";
                capitalize = true;
                continue;
        }

        if (capitalize)
        {
            result += char.ToUpper(character);
            capitalize = false;
        }
        else
        {
            result += char.ToLower(character);
        }
    }

    return result;
}

string GetName()
{
    return names.Reverse().Aggregate("", (current, name) => current + Camelize(name));
}

TypeDescription CreateTypeDescription(string name, dynamic obj)
{
    var root = obj;
    var arrayDepth = 0;
    while (obj.ContainsKey("type") && obj["type"] == "array")
    {
        arrayDepth++;
        obj = obj["items"];
    }

    if (duplicates.ContainsKey(obj))
    {
        return duplicates[obj];
    }

    names.Push(Camelize(arrayDepth > 0 ? plural.Singularize(name) : name));
    var type = GetName();
    bool hasType = obj.ContainsKey("type");
    if (hasType && obj["type"] == "string" && obj.ContainsKey("enum"))
    {
        var values = new List<string>();
        foreach (var value in obj["enum"])
        {
            values.Add(Camelize(value));
        }

        enumerations[type] = new Enumeration(values);
    }
    else if (hasType && obj["type"] == "object" || obj.ContainsKey("allOf"))
    {
        var descriptor = new Description(ReadProperties(obj));
        descriptors[type] = descriptor;
    }
    else if (hasType)
    {
        type = obj["type"];
    }

    var nullable = root.ContainsKey("nullable") && root["nullable"] == "true";
    var description = new TypeDescription(type, nullable, arrayDepth);
    duplicates[(object) obj] = description;
    names.Pop();

    return description;
}

Dictionary<string, TypeDescription> ReadProperties(dynamic schema)
{
    var properties = new Dictionary<string, TypeDescription>();
    if (schema.ContainsKey("allOf"))
    {
        var allOf = new List<Dictionary<string, TypeDescription>>();
        foreach (var subSchema in schema["allOf"])
        {
            allOf.Add(ReadProperties(subSchema));
        }

        properties.AddRange(allOf.ToArray());
    }
    else if (schema.ContainsKey("properties"))
    {
        foreach (var prop in schema["properties"])
        {
            properties[Camelize(prop.Key)] = CreateTypeDescription(prop.Key, prop.Value);
        }
    }

    return properties;
}