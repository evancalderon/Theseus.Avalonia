using System.Text;
using APIWriter;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

var web = new HttpClient();
var api = await web.GetStreamAsync("https://raw.githubusercontent.com/modrinth/docs/master/static/openapi.yaml");

var deserializer = new DeserializerBuilder()
    .WithNamingConvention(UnderscoredNamingConvention.Instance)
    .Build();

dynamic doc = deserializer.Deserialize(new StreamReader(api))!;
var components = doc["components"];
var parameter_types = components["parameters"];
var schemas = components["schemas"];
var paths = doc["paths"];

var enumerators = new List<Enumerator>();
var descriptors = new List<Descriptor>();
var methods = new List<Method>();

Queue<string> names = new();

string Singularize(string name)
{
    var result = "";

    if (name.EndsWith("ies"))
    {
        result = name[..^3] + 'y';
    }
    else if (name.EndsWith("s"))
    {
        result = name[..^1];
    }

    return result;
}

string GetName()
{
    var result = "";

    foreach (var name in names)
    {
        var capitalize = true;
        foreach (var character in name)
        {
            if (character == '_')
            {
                capitalize = true;
                continue;
            }

            if (capitalize)
            {
                result += char.ToUpper(character);
                capitalize = false;
            }
            else
            {
                result += character;
            }
        }
    }

    return result;
}

List<Property> ReadProperties(dynamic schema)
{
    var properties = new List<Property>();
    if (schema.ContainsKey("allOf"))
    {
        foreach (var subSchema in schema["allOf"])
        {
            properties.AddRange(ReadProperties(subSchema));
        }
    }
    else
    {
        foreach (var prop in schema["properties"])
        {
            var type = prop.Value["type"];
            bool isArray = prop.Value["type"] == "array";
            if (isArray)
            {
                var items = prop.Value["items"]; 
                if (items.ContainsKey("allOf") || items["type"] == "object")
                {
                    names.Enqueue(Singularize(prop.Key));
                    var descriptor = new Descriptor(GetName(), ReadProperties(items));
                    descriptors.Add(descriptor);
                    names.Dequeue();

                    type = descriptor.Name;
                }
                else if (items["type"] == "string" && items.ContainsKey("enum"))
                {
                    names.Enqueue(prop.Key);
                    var values = new List<string>();
                    foreach (var value in items["enum"])
                    {
                        values.Add(value);
                    }
                    enumerators.Add(new Enumerator(GetName(), values));
                    names.Dequeue();
                }
                else
                {
                    type = items["type"];
                }
            }

            var nullable = prop.Value.ContainsKey("nullable") && prop.Value["nullable"] == "true";
            properties.Add(new Property(prop.Key, type, nullable, isArray));
        }
    }

    return properties;
}

foreach (var param in parameter_types)
{
    var schema = param.Value["schema"];
    
    if (schema["type"] == "string" && schema.ContainsKey("enum"))
    {
        var values = new List<string>();
        foreach (var value in schema["enum"])
        {
            values.Add(value);
        }
        enumerators.Add(new Enumerator(param.Key, values));
    }
}

foreach (var schema in schemas)
{
    names.Enqueue(schema.Key);
    var descriptor = new Descriptor(GetName(), ReadProperties(schema.Value));
    descriptors.Add(descriptor);
    names.Dequeue();
}

foreach (var path in paths)
{
}

var output = new StringBuilder();

output.AppendLine(@"
/*
 * This file is automatically generated. Modify at your own risk.
 */

namespace API;
");

foreach (var enume in enumerators)
{
    output.AppendLine($"public enum {enume.Name}\n{{");
    foreach (var val in enume.Values)
    {
        output.AppendLine($"    {val},");
    }
    output.AppendLine("}\n");
}

foreach (var desc in descriptors)
{
    output.Append($"public record {desc.Name}(\n    ");
    output.Append(
        string.Join(
            ",\n    ", 
            desc.Properties.Select(prop => $"{prop.Type}{(prop.Array ? "[]" : "")} {prop.Name}")));
    output.AppendLine(");");
}

File.WriteAllText("API.cs", output.ToString());
