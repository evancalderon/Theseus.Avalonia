using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using APIWriter;
using Pluralize.NET.Core;
using YamlDotNet.Core;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

var plural = new Pluralizer();
var web = new HttpClient();
var api = await web.GetStringAsync("https://raw.githubusercontent.com/trash-panda-mc/docs/master/static/openapi.yaml");
File.WriteAllText("openapi.yaml", api);

var deserializer = new DeserializerBuilder()
    .WithNamingConvention(UnderscoredNamingConvention.Instance)
    .Build();

dynamic doc;
using (var sr = new StringReader(api))
{
    doc = deserializer.Deserialize(new Parser(sr))!;
}

var components = doc["components"];
var parameterTypes = components["parameters"];
var schemas = components["schemas"];
var paths = doc["paths"];

var duplicates = new Dictionary<object, TypeDescription>();
var enumerations = new Dictionary<string, Enumeration>();
var descriptors = new Dictionary<string, Description>();
var methods = new Dictionary<string, Method>();
var names = new Stack<string>();

// Parse document
foreach (var param in parameterTypes)
{
    CreateTypeDescription(param.Key, param.Value["schema"]);
}

foreach (var schema in schemas)
{
    CreateTypeDescription(schema.Key, schema.Value);
}

foreach (var path in paths)
{
    var counter = 0;
    var key = Regex.Replace(
        (string) path.Key,
        @"{(.*?)}",
        _ => $"{{{counter++}}}");
    foreach (var method in path.Value)
    {
        if (method.Value.ContainsKey("security"))
        {
            continue;
        }
        
        var name = method.Value["operationId"];
        names.Push(Camelize(name));

        var parameters = new Dictionary<string, MethodParameter>();
        if (method.Value.ContainsKey("parameters"))
        {
            foreach (var param in method.Value["parameters"])
            {
                var inType = param["in"];
                var paramName = param["name"];
                var schema = param["schema"];

                var typeDesc = CreateTypeDescription(paramName, schema);
                parameters[Camelize(paramName, false)] =
                    new MethodParameter(Camelize(inType), typeDesc);
            }
        }

        if (method.Value.ContainsKey("requestBody"))
        {
            Dictionary<dynamic, dynamic> requestBody = method.Value["requestBody"]["content"];
            var (contentType, content) = requestBody.First();

            var typeDesc = CreateTypeDescription("RequestBody", content["schema"]);
            parameters["requestBody"] = new MethodParameter("RequestBody", typeDesc);
        }

        methods[GetName()] = new Method(method.Key, key, parameters);
        names.Pop();
    }
}


// Generate output file
var output = new StringBuilder();

output.AppendLine(@"
/*
 * This file is automatically generated.
 */

using System;
using boolean = System.Boolean;
using integer = System.Int32;
namespace Theseus.Avalonia;
[AttributeUsage(AttributeTargets.Parameter)]
public class PathAttribute : Attribute
{
}
[AttributeUsage(AttributeTargets.Parameter)]
public class QueryAttribute : Attribute
{
}
[AttributeUsage(AttributeTargets.Parameter)]
public class RequestBodyAttribute : Attribute
{
}
".Trim());

foreach (var (name, enume) in enumerations)
{
    output.AppendLine($"public class {name}\n{{");
    output.AppendLine("\tpublic string Name;");
    output.AppendLine($"\tprivate {name}(string name)\n\t{{\n\t\tName = name;\n\t}}");
    output.AppendLine("\tpublic override string ToString()\n\t{\n\t\treturn Name;\n\t}");
    output.AppendLine($"\tpublic static implicit operator string({name} value)\n\t{{\n\t\treturn value.Name;\n\t}}");
    output.Append(enume.Values.Aggregate("",
        (cur, value) =>
            cur +
            $"\tpublic static readonly {name} {value.Key} = new(\"{value.Value}\");\n"));
    output.AppendLine("}");
}

foreach (var (name, desc) in descriptors)
{
    output.Append($"public struct {name}\n{{\n");
    output.Append(
        desc.Properties.Aggregate("",
            (cur, prop) =>
                prop switch
                {
                    var (pName, type) =>
                        cur +
                        $"\t{type.TypeName}" +
                        string.Concat(Enumerable.Repeat("[]", type.ArrayDepth)) +
                        (type.Nullable ? "?" : "") +
                        $" {pName};\n"
                }));
    output.AppendLine("}");
}

output.AppendLine(@"
public class ModrinthClient
{
    private System.Net.Http.HttpClient client = new System.Net.Http.HttpClient();
    public ModrinthClient()
    {
        client.DefaultRequestHeaders.UserAgent.Add(
            new System.Net.Http.Headers.ProductInfoHeaderValue(""Theseus.Avalonia"", ""1.0""));
        client.DefaultRequestHeaders.UserAgent.Add(
            new System.Net.Http.Headers.ProductInfoHeaderValue(""(https://github.com/trash-panda-mc/theseus.avalonia)""));
    }
".Trim());
foreach (var (name, method) in methods)
{
    output.Append($"\tpublic dynamic {name}(");
    output.Append(
        string.Join(", ",
            method.Parameters.Select(
                _ => _ switch
                {
                    var (pName, param) =>
                        $"[{param.Kind}]" +
                        $" {param.Type.TypeName}" +
                        $"{string.Concat(Enumerable.Repeat("[]", param.Type.ArrayDepth))}" +
                        $"{(param.Type.Nullable || param.Kind == "Query" ? "?" : "")}" +
                        $" {pName}"
                })));
    output.AppendLine(")\n\t{");

    // TODO
    output.AppendLine("\t\tthrow new NotImplementedException();");

    output.AppendLine("\t}");
}

output.Append('}');

File.WriteAllText("Modrinth.cs", output.ToString());


string Camelize(string name, bool capitalizeFirstWord = true)
{
    var result = "";

    var capitalize = capitalizeFirstWord;
    foreach (var character in name)
    {
        switch (character)
        {
            case '_':
                capitalize = true;
                continue;
            case '|':
                result += "Or";
                capitalize = true;
                continue;
        }

        if (!char.IsLetterOrDigit(character))
        {
            capitalize = true;
            continue;
        }

        if (capitalize)
        {
            result += char.ToUpper(character);
            capitalize = false;
        }
        else
        {
            result += character;
        }
    }

    return result;
}

string GetName()
{
    return names.Reverse().Aggregate("", (current, name) => current + Camelize(name));
}

TypeDescription CreateTypeDescription(string name, dynamic obj)
{
    var root = obj;
    var arrayDepth = 0;
    while (obj.ContainsKey("type") && obj["type"] == "array")
    {
        arrayDepth++;
        obj = obj["items"];
    }

    if (duplicates.ContainsKey(obj))
    {
        return duplicates[obj];
    }

    names.Push(Camelize(arrayDepth > 0 ? plural.Singularize(name) : name));
    var type = GetName();
    bool hasType = obj.ContainsKey("type");
    if (hasType && obj["type"] == "string" && obj.ContainsKey("enum"))
    {
        var values = new Dictionary<string, string>();
        foreach (var value in obj["enum"])
        {
            values.Add(Camelize(value), value);
        }

        enumerations[type] = new Enumeration(values);
    }
    else if (hasType && obj["type"] == "object" || obj.ContainsKey("allOf"))
    {
        var descriptor = new Description(ReadProperties(obj));
        descriptors[type] = descriptor;
    }
    else if (hasType)
    {
        type = obj["type"];
    }

    var nullable = root.ContainsKey("nullable") && root["nullable"] == "true";
    var description = new TypeDescription(type, nullable, arrayDepth);
    duplicates[(object) obj] = description;
    names.Pop();

    return description;
}

Dictionary<string, TypeDescription> ReadProperties(dynamic schema)
{
    var properties = new Dictionary<string, TypeDescription>();
    if (schema.ContainsKey("allOf"))
    {
        var allOf = new List<Dictionary<string, TypeDescription>>();
        foreach (var subSchema in schema["allOf"])
        {
            allOf.Add(ReadProperties(subSchema));
        }

        properties.AddRange(allOf.ToArray());
    }
    else if (schema.ContainsKey("properties"))
    {
        foreach (var prop in schema["properties"])
        {
            properties[Camelize(prop.Key)] = CreateTypeDescription(prop.Key, prop.Value);
        }
    }

    return properties;
}